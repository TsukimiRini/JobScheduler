# 本地作业调度管理系统

## 任务目标
开发一个本地的作业调度管理系统，要求实现作业提交，作业查询以及作业取消三个接口的功能，每个作业都会指定执行的指令，环境配置参数，最大运行时间，作业所占用的CPU核数。要求能够自动对这些作业进行管理（通过任务队列管理），确保执行的任务之间不会冲突，计算资源合理分配。

## 完成情况

### 功能实现情况
基于linux库，将作业提交、作业查询及作业取消这三个功能分别封装为函数，返回restful api风格的响应，形式上均为JSON对象，包括响应状态码、响应消息以及数据三部分。

- 作业提交：输入参数为作业执行命令、为作业设置指定的环境变量、作业最大运行时间和每个任务使用的核数；返回的响应数据中包含作业id信息。
- 作业查询：输入参数为作业id；返回的响应数据中包含作业id、作业执行状态、作业参数（执行命令、环境变量、最大运行时间和使用核数）、作业日志路径（stdout和stderr分别存在两个路径中）。
- 作业取消：输入参数为作业id；返回的相应数据为空。

### 接口详解
三个功能对应的接口实现都在[client.c源文件](https://github.com/TsukimiRini/JobScheduler/blob/main/client.c)下。

作为参考，代码仓中[main.c源文件](https://github.com/TsukimiRini/JobScheduler/blob/main/main.c)提供了三个功能的使用示例，分别调用了[sever_ctl源文件](https://github.com/TsukimiRini/JobScheduler/blob/main/server_ctl.c)的三个封装好的函数，以达到用命令行的形式测试三个主要接口的目的。

**作业提交**对应的接口为：

```c
cJSON *c_submit_job(int server_socket, char **command, struct Env **env,
                    int deadtime, int cpus_per_task);
```

输入参数与作业提交的请求内容一一对应，
- command为指向字符串数组的指针，对应作业执行命令。数组内按序存储命令行程序名和参数名。
- env为指向Env结构体数组的指针，对应为作业设置指定的环境变量。数组内每个Env结构体对应用户设置的一个环境变量，Env结构体内包含环境变量名和值信息。
- deadtime为整数值，对应作业最大运行时间（单位为秒）。
- cpus_per_task为整数值，对应每个任务使用的核数。

**作业查询**对应的接口为：

```c
cJSON *c_get_job_info(int server_socket, char *uuid);
```

输入参数为需要查询的作业id。

**作业取消**对应的接口为：

```c
cJSON *c_cancel_job(int server_socket, char *uuid);
```

输入参数为需要查询的作业id。

还有一些基础模块相关的接口，在server_ctl.c中：

**运行服务端作业队列管理模块**的接口为：

```c
int server_up();
```

调用该接口会启动服务端作业队列管理模块作为守护进程，并开启socket端口。

**关闭服务端作业队列管理模块**的接口为：

```c
int server_down();
```

调用该接口会关闭正在运行的服务端作业队列管理模块。


### 使用流程
本地作业调度管理系统主要分为两部分：服务端作业队列管理模块和客户端请求提交模块。

在使用时，需要先启动服务端作业队列管理模块，作为守护进程在后台运行。它的作用是接收和处理客户端请求，并定时检查作业运行情况。

服务端作业队列管理模块运行的前提下，用户提交的请求会调用客户端请求提交模块，将请求提交到服务端，由服务端处理后返回响应。

因此，运行本地作业调度管理系统的流程为：

- 启动服务端作业队列管理模块。
- 当用户需要提交/查询/取消作业时，调用客户端请求提交模块，向服务端发送请求。
- 服务端返回请求处理结果，客户端请求提交模块解析后返回一个JSON响应。
- 重复第二、三步直到所有的客户端操作已经完成。
- 关闭服务端作业队列管理模块。

### 如何测试

此项目通过命令行的形式提供了对各个接口的简单测试方法。如果想以这种方式测试，可以通过以下步骤配置：

- 在根目录编译项目，生成可执行文件。

```shell
cmake ./
make
```

- 执行`job_scheduler`，传入`-s`flag启动服务端。

```shell
./job_scheduler -s
```

- 传入`-n`/`-c [jobid]`/`-i [jobid]`flag，分别可以提交作业/取消作业/查询作业。提交作业时传入的执行命令或运行环境需要在源码中修改。

```shell
./job_scheduler -n
./job_scheduler -c 918f3c5e-92c3-4193-90df-469900fc1f09
./job_scheduler -i 918f3c5e-92c3-4193-90df-469900fc1f09
```

- 传入`-k`flag关闭服务端。

```shell
./job_scheduler -k
```

## 具体实现

### 基础框架

本地作业调度管理系统用C语言编写，基于linux库和第三方库cJSON开发。主要运行原理是通过socket通信让服务端作业队列管理模块在后台运行，开放socket端口等待客户端请求，处理作业提交、查询、取消的业务逻辑。

- **数据结构** 主要的数据结构有：(1) 排队作业队列，维护还未结束的作业，队列的特性保证要求等量资源的作业中，先提交请求的会先被处理，每个队列中的节点是一个Job结构体，存储了各种作业相关的信息，如最大运行时间等作业参数、进程号、日志路径，(2) 已完成作业队列，维护历史数据以供用户查询，包含已经成功运行完毕的作业、被取消的作业、出现错误的作业等，(3) socket信息结构体，包含信息类型和一个union数据，不同的信息类型会对应不同的union成员。(4) socket连接数组，包括所有目前跟服务端连接的客户端socket连接信息，(5) 一些存储子信息的结构体或枚举类型，如存储环境变量信息的结构体Env。
- **Socket通信** 服务端和客户端之间通过Socket套接字通信，以实现本地作业调度管理系统的各种功能。服务端和客户端之间通信的类型有：(1) 客户端向服务端发送：关闭服务端请求、提交作业请求、查询作业请求、取消作业请求、作业运行结束通知，(2) 服务端向客户端发送：作业提交响应、作业查询响应、运行作业命令、取消作业命令。
- **服务端主循环** 服务端启动后，创建socket套接字并进入主循环。主循环会依次：关停运行时间大于规定最大运行时间的作业，检查套接字上请求通信的客户端，对客户端发来的请求进行处理（如果收到服务端关闭请求，退出循环），搜索并运行下一个可以运行的作业。

### 作业提交

当用户发出作业提交请求，程序流程如下：

- 客户端封装作业提交请求，连接服务端socket套接字，向服务端发送请求。
- 服务端解析作业提交请求，判断作业需求资源是否大于最大资源，如果是则通知客户端提交作业失败，否则初始化作业，生成作业id，把作业加入排队作业队列，通知客户端提交作业成功。
- 客户端收到作业提交成功的信息后，进入休眠状态，等待服务端通知。
- 当作业被选中运行时，服务端发送作业运行通知，客户端运行子进程，向服务端返回相关信息并调用execvp接口运行目标命令，父进程等待子进程运行完毕。
- 子进程运行完毕后，父进程向客户端发送消息通知作业已经运行完毕。

### 作业查询

当用户发出作业查询请求，程序流程如下：

- 客户端封装作业查询请求，连接服务端socket套接字，向服务端发送请求。
- 服务端解析作业查询请求，根据请求中的作业id字段，在排队作业队列和已完成作业队列中查找对应作业。
- 服务端将作业的信息封装到socket信息中，包括作业状态等。当不存在对应作业时，作业状态被置为Null。
- 客户端收到服务端发来的响应，根据作业状态和参数等信息填写需要返回的JSON对象。

### 作业取消

当用户发出作业取消请求，程序流程如下：

- 客户端封装作业取消请求，连接服务端socket套接字，向服务端发送请求。
- 服务端解析作业查询请求，根据请求中的作业id字段，在排队作业队列和已完成作业队列中查找对应作业。
- 假如作业不存在/已经结束，直接封装socket信息发送给客户端，否则向运行该作业的客户端进程发送SIGINT信号。客户端进程注册了自定义的SIGINT处理句柄，收到SIGINT后会杀死子进程。
- 杀死子进程后，客户端父进程对服务端发送一个作业已停止的消息。
- 服务端收到作业已停止的消息，执行后续操作，包括socket清理、向请求取消作业的客户端发送响应等。

## 可能存在的问题

- 没有接触到实际应用场景下的用户行为，如果存在意料之外的行为，程序的行为可能不够鲁棒。
- 目前作业资源分配策略是竞争式的先入先出，当资源总量较少时，请求资源量比较大的作业等待时间可能会偏长。